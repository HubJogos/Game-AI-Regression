# -*- coding: utf-8 -*-
"""Regressao_modelos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ODbrkzuH6S8_uWcpHg6QjgzR99yNTS9K

# **Regressão Linear**

# **Configurações iniciais da regressão**
1.   Importando as bibliotecas que serão utilizadas
1.   Importando o dataset geral
2.   Filtrando os dados mais importantes
3.   Gerando a matriz de confusão do dataset filtrado
4.   Determinando as variáveis dependentes e independentes
"""

import socket
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import io
from sklearn.linear_model import LinearRegression
from sklearn.multioutput import MultiOutputRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import *
from sklearn.metrics import r2_score
from plotnine import ggplot, aes, geom_point, geom_line
from plotnine.themes import theme_minimal
from google.colab import files

# carregando o dataset
data_to_load = files.upload()
test_df = pd.read_csv(io.BytesIO(data_to_load['MapGenData - Form Responses 2.csv']))
test_df

# Utilizando alguns dados para realizar os testes
df = test_df[['Tempo no mapa gerado', 'Tamanho do mapa', 'Passos', 'Porcentagem de inimigos derrotados', 'Derrotas','Notas']]
df

# matriz
sns.heatmap(df.corr(), annot=True, vmin=-1, vmax=1)
plt.show()

# y -> target (variavel dependete)
# x -> variaveis independentes
y = test_df[["Notas", "Derrotas"]]    
x = test_df[['Tempo no mapa gerado', 'Tamanho do mapa', 'Passos', 'Porcentagem de inimigos derrotados']]

"""# **Dividindo o dataset em: dataset de treino e dataset de teste**"""

# fazendo split do dataset
x_train, x_test, y_train, y_test = train_test_split(x, y)

x_train

x_test

y_train

y_test

"""# **Treinamento e predição dos valores com o dataset de treinamento**"""

# criando um modelo de regressão linear
reg = LinearRegression()
mult = MultiOutputRegressor(reg)

# treinando o modelo de regressão
mult.fit(x_train,y_train)

# resultados
# um valor negativo do coeficiente indica uma relação inversa. A variável independente
# aumenta e a variável dependente diminui.
mult.estimators_[0].coef_ #revisar isto

# resultados
mult.estimators_[0].intercept_ #revisar isto

# predição
#y_true = df.Notas
#y_pred = reg.predict(df[['Tempo no mapa gerado', 'Tamanho do mapa', 'Passos', 'Porcentagem de inimigos derrotados']])
y_true = y_train
y_pred = mult.predict(x_train) # talvez fosse bom ter um outro dataset aqui, pois estou utilizando o mesmo dataset que usei para treinar a ia
y_pred

# separando as predições em vetores separados
prediction_results = np.hsplit(y_pred,2)
prediction_results

"""# **Métricas de erro**"""

# utilizando a métrica de erro mean squared error
model_error_squared = mean_squared_error(y_true, y_pred)
print(f"The mean squared error of the optimal model is {model_error_squared:.2f}")

# utilizando a métrica de erro mean absolute error
model_error_absolute = mean_absolute_error(y_true, y_pred)
print(f"The mean absolute error of the optimal model is {model_error_absolute:.2f}")

# melhor valor esperado é 1, valores menores são piores resultados
model_error_variance = explained_variance_score(y_true, y_pred)
print(f"The mean absolute error of the optimal model is {model_error_variance:.2f}")

# utilizando a métrica de erro mean pinball error
model_error_pinball_loss = mean_pinball_loss(y_true, y_pred, alpha = 0.5)
print(f"The mean absolute error of the optimal model is {model_error_pinball_loss:.2f}")

# variância
# metrica comum para medir a regressão linear, estimando a proporção da variância.
# Os resultados vão de 0 a 1, quanto maior melhor.
model_error_r2 = r2_score(y_true, y_pred)
print(f"The mean r2 of the optimal model is {model_error_r2:.2f}")

"""# **Resultados finais do dataset de treinamento**"""

# Visualização
#df['fitted'] = y_pred
#df
train_result = pd.concat([x_train, y_train], axis="columns")
train_result['Notas pred'] = prediction_results[0]
train_result['Derrotas pred'] = prediction_results[1]
train_result

ggplot(aes('Tempo no mapa gerado', 'Tamanho do mapa', 'Passos', 'Porcentagem de inimigos derrotados', "Derrotas",'Notas'), train_result) \
    + geom_point(alpha = 0.5, color = "#2c3e50") \
    + geom_line(aes(y = 'Notas pred'), color = 'blue') \
    + geom_line(aes(y = 'Derrotas pred'), color = 'green') \
    + theme_minimal()

"""# **Utilizando o dataset de testes**"""

# usando o dataset de testes
# aqui não iremos usar o método de fit para realizar o treinamento
y_true_test = y_test
y_pred_test = mult.predict(x_test)
y_pred_test

prediction_results_test = np.hsplit(y_pred_test,2)
prediction_results_test

train_result_test = pd.concat([x_test, y_test], axis="columns")
train_result_test['Notas pred'] = prediction_results_test[0]
train_result_test['Derrotas pred'] = prediction_results_test[1]
train_result_test

ggplot(aes('Tempo no mapa gerado', 'Tamanho do mapa', 'Passos', 'Porcentagem de inimigos derrotados', "Derrotas",'Notas'), train_result_test) \
    + geom_point(alpha = 0.5, color = "#2c3e50") \
    + geom_line(aes(y = 'Notas pred'), color = 'blue') \
    + geom_line(aes(y = 'Derrotas pred'), color = 'green') \
    + theme_minimal()


"""# **Exemplo de comunicacão com a unity**"""

import socket

s = socket.socket()
print("Socket Created")

s.bind(('localhost',5058))

s.listen(3)
print("Waiting for a Connection !!")

while True:
    c, addr = s.accept()
    name = c.recv(1024).decode()
    print("Connected with :",addr, " ", name)
    c.send(bytes("Welcome to Socket Programming",'utf-8', name))
    c.close()